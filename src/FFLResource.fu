// The reason why you might be seeing so many errors is because this file requires Readers.fu

/// ZLib compression implementation.
/// Must be overrided using a library for your target language!
public static class ZlibImpl {
	/// Write the decompressed contents of `input` into `output`.
	/// `windowBits` and `originalSize` must also be specified.
	public static void Decompress(byte[] input, byte[] output, byte windowBits, uint originalSize) {
		Console.WriteLine("!! DEFAULT ZlibImpl DOES NOT DO ANYTHING !!");
		assert false, "You're still using the default ZlibImpl, please override it!";
	}

	/// Write the Compressed contents of `input` into `output`.
	/// `level` and `windowBits` must also be specified.
	public static void Compress(byte[] input, byte[] output, byte level, byte windowBits) {
		Console.WriteLine("!! DEFAULT ZlibImpl DOES NOT DO ANYTHING !!");
		assert false, "You're still using the default ZlibImpl, please override it!";
	}
}

public enum FFLiTextureFormat {
	Greyscale = 0,
	GreyscaleAlpha = 1,
	RGBA = 2
}

/// The index that each shape element is stored at.
/// Exmaple: `data[FFLiResourceShapeElementType.Position.ToInt()]` would get vertex position data.
public enum FFLiResourceShapeElementType {
	Position = 0,
	Normal = 1,
	Texcoord = 2,
	Tangent = 3,
	Color = 4,
	Index = 5,
	TransformHair = 6,
	TransformFaceline = 7,
	BoundingBox = 8
}

public class Vec3 {
	public float x = Math.NaN;
	public float y = Math.NaN;
	public float z = Math.NaN;

	/// Reads 3 IEEE 754 4-byte floats into `x`, `y` and `z` respectively.
	public void FromByteReader!(ByteReader() data) {
		x = data.ReadFloat();
		y = data.ReadFloat();
		z = data.ReadFloat();
	}

	/// Convenience function to set `x`, `y` and `z` to `Math.NaN`.
	public void SetNaN!() {
		x = Math.NaN;
		y = Math.NaN;
		z = Math.NaN;
	}
}

/// Represents the minimum and maximum values of vertex positions in shapes.
public class BoundingBox {
	public Vec3() min;
	public Vec3() max;

	/// Reads 2 `Vec3`s into `min` and `max` respectively.
	public void FromByteReader!(ByteReader() data) {
		min.FromByteReader(data);
		max.FromByteReader(data);
	}

	/// Convenience function to set the `x`, `y` and `z` values of `min` and `max` to `Math.NaN`.
	public void SetNaN!() {
		min.SetNaN();
		max.SetNaN();
	}
}

/// Convenience class containing 1 function to convert `FFLiResourcePartsInfo.WindowBits` to ZLib `windowBits`.
public static class WindowBitConverter {
	/// Converts `FFLiResourcePartsInfo.WindowBits` to ZLib `windowBits`.
	public static byte FFLiResourceWindowBitsToZlibWindowBits(byte windowBits) {
		if (windowBits <= 7) {return windowBits + 8;} // BITS_ZLIB 8-15
		if (windowBits >= 8 && windowBits <= 15) {return windowBits + 16;} // BITS_GZIP 8-15
		if (windowBits == 16) {return 32 + 15;} // BITS_ZLIB_OR_GZIP_15
		return 15;
	}
}

/// Passed to `FFLResource.FromByteReader` to provide more options for memory-management.
public class FFLiResourceLoaderObjects {
	public FFLiResourceHeader! ResourceHeader;
	public FFLiResourceTextureHeader! TextureHeader;
	public FFLiResourceShapeHeader! ShapeHeader;

	public FFLiResourcePartsInfo![3] TextureBeard;
	public FFLiResourcePartsInfo![132] TextureCap;
	public FFLiResourcePartsInfo![62] TextureEye;
	public FFLiResourcePartsInfo![24] TextureEyebrow;
	public FFLiResourcePartsInfo![12] TextureWrinkle;
	public FFLiResourcePartsInfo![12] TextureMakeup;
	public FFLiResourcePartsInfo![9] TextureGlasses;
	public FFLiResourcePartsInfo![2] TextureMole;
	public FFLiResourcePartsInfo![37] TextureMouth;
	public FFLiResourcePartsInfo![6] TextureMustache;
	public FFLiResourcePartsInfo![18] TextureNoseline;

	public FFLiResourcePartsInfo![4] ShapeBeard;
	public FFLiResourcePartsInfo![132] ShapeCapNormal;
	public FFLiResourcePartsInfo![132] ShapeCapHat;
	public FFLiResourcePartsInfo![12] ShapeFaceline;
	public FFLiResourcePartsInfo![1] ShapeGlasses;
	public FFLiResourcePartsInfo![12] ShapeMask;
	public FFLiResourcePartsInfo![18] ShapeNoseline;
	public FFLiResourcePartsInfo![18] ShapeNose;
	public FFLiResourcePartsInfo![132] ShapeHairNormal;
	public FFLiResourcePartsInfo![132] ShapeHairHat;
	public FFLiResourcePartsInfo![132] ShapeForeheadNormal;
	public FFLiResourcePartsInfo![132] ShapeForeheadHat;
}

public class FFLiPartData {
	public bool Used = false;
	public FFLiPartDataHeader! Header;
	public FFLiPartDataFooter! Footer;
	public byte[]#[6] Data;

	public void FromByteReader!(ByteReader() bUtils, uint size) {
		for (int i = 0; i < 6; i++) {
			if (Header.ElementSize[i] <= 20000000 && Header.ElementSize[i] > 0) {
				bUtils.Seek(Header.ElementOffset[i]);
				bUtils.ReadRaw(Header.ElementSize[i], Data[i]);
			}
		}

		bool a = true;
		foreach (uint i in Header.ElementSize) {
			if (i <= 20000000 && i > 0) {
				a = false;
			}
		}

		if (a) {
			SetUnused();
			return;
		}

		bUtils.Seek(size - 0x10);
		Footer.FromByteReader(bUtils);
	}

	public ByteReader() LoadHeader!(byte[]# data) {
		ByteReader() bUtils;
		bUtils.data = data;

		Header.FromByteReader(bUtils);

		Used = true;
		return bUtils;
	}

	public void SetUnused!() {
		Used = false;
		Header.SetUnused();
	}
}

public class FFLiPartDataHeader {
	public int[6] ElementOffset;
	public int[6] ElementSize;
	public BoundingBox() BoundingBox;
	public Vec3()[6] Transform;

	public void FromByteReader!(ByteReader() bUtils) {
		for (int i = 0; i < 6; i++) {
			ElementOffset[i] = bUtils.ReadSInt(4);
		}
		for (int i = 0; i < 6; i++) {
			ElementSize[i] = bUtils.ReadSInt(4); 
		}
		if (ElementSize[FFLiResourceShapeElementType.Index.ToInt()] < 20000000) {
			ElementSize[FFLiResourceShapeElementType.Index.ToInt()] *= 2;
		}

		BoundingBox.FromByteReader(bUtils);
		for (int i = 0; i < 6; i++) {
			Transform[i].FromByteReader(bUtils);
		}
	}

	public void SetUnused!() {
		BoundingBox.SetNaN();
	}
}

public class FFLiPartDataFooter {
	public uint MipOffset;
	public ushort Width;
	public ushort Height;
	public FFLiTextureFormat Format;
	public byte MipCount;

	public void FromByteReader!(ByteReader() data) {
		MipOffset = data.ReadUInt(4);
		Width = data.ReadUShort(2);
		Height = data.ReadUShort(2);
		byte t = data.ReadByte();
		if (t < 3) {
			Format = FFLiTextureFormat.FromInt(t);
		}
		MipCount = data.ReadByte();
		data.Padding(2);
	}
}

public class FFLiResourcePartsInfo {
	public uint Offset;
	public uint UncompressedSize;
	public uint CompressedSize;
	public byte CompressionLevel;
	public byte WindowBits;
	public byte MemoryLevel;
	public byte Strategy;
	public FFLiPartData! PartData;
	ByteReader() BReader;

	public void FromByteReader!(ByteReader() data, FFLiResourceLoaderObjects() objects) {
		Offset = data.ReadUInt(4);
		UncompressedSize = data.ReadUInt(4);
		assert (UncompressedSize < 20000000) && ((UncompressedSize % 2) == 0), "Uncompressed Size invalid (should pass UncompressedSize < 20000000 and (UncompressedSize % 2) == 0)";
		CompressedSize = data.ReadUInt(4);
		assert CompressedSize <= 20000000, "Compressed Size too large (should be <= 20000000)";
		CompressionLevel = data.ReadByte();
		assert UncompressedSize == 0 || CompressionLevel < 11, "Compression Level invalid (should pass UncompressedSize == 0 or CompressionLevel < 11)";
		WindowBits = data.ReadByte();
		MemoryLevel = data.ReadByte();
		assert UncompressedSize == 0 || MemoryLevel < 9, "Memory Level invalid (should pass UncompressedSize == 0 or MemoryLevel < 9)";
		Strategy = data.ReadByte();
		assert Strategy <= 6, "Strategy too large (should be <= 6)";
	}

	public void LoadHeader!(ByteReader() data, byte[]# dataBuffer, byte[]! compressedBuffer) {
		if (UncompressedSize == 0) {
			PartData.SetUnused();
			return;
		}
		uint oOffset = data.offset;
		data.Seek(Offset);
		if (Strategy == 5) {
			data.ReadRaw(CompressedSize, dataBuffer);
			BReader = PartData.LoadHeader(dataBuffer);
			data.Seek(oOffset);
			return;
		}
		data.ReadRaw(CompressedSize, compressedBuffer);
		ZlibImpl.Decompress(compressedBuffer, dataBuffer, WindowBitConverter.FFLiResourceWindowBitsToZlibWindowBits(WindowBits), UncompressedSize);
		BReader = PartData.LoadHeader(dataBuffer);
		data.Seek(oOffset);
	}

	public void LoadPart!() {
		if (PartData.Used) {
			PartData.FromByteReader(BReader, UncompressedSize);
		}
	}
}

public class FFLiResourceHeader {
	public uint UncompressedBufferSize;
	public uint ExpandedBufferSize;
	public bool IsExpand;

	public void FromByteReader!(ByteReader() data, FFLiResourceLoaderObjects() objects) {
		assert data.ReadUTF8(4) == "FFRA", "Magic Header invalid (should be FFRA)";
		assert data.ReadUInt(4) == 0x00070000, "Version invalid (should be 0x00070000)";
		UncompressedBufferSize = data.ReadUInt(4);
		assert UncompressedBufferSize >= 1024, "Uncompressed Buffer Size too small (should be >=1024)";
		ExpandedBufferSize = data.ReadUInt(4);
		assert ExpandedBufferSize >= 1, "Expanded Buffer Size too small (should be >=1)";
		IsExpand = (data.ReadUInt(4) == 1);
	}
}

public class FFLiResourceTextureHeader {
	public uint[11] TextureMaxSize;

	public void FromByteReader!(ByteReader() data, FFLiResourceLoaderObjects() objects) {
		for (int i = 0; i < 11; i++) {
			TextureMaxSize[i] = data.ReadUInt(4);
			assert TextureMaxSize[i] < 20000000 && (TextureMaxSize[i] % 4) == 0, "Texture Max Size invalid (should pass TextureMaxSize < 20000000 and (TextureMaxSize % 4) == 0)";
		}
		for (int i = 0; i < 3; i++) {
			objects.TextureBeard[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 132; i++) {
			objects.TextureCap[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 62; i++) {
			objects.TextureEye[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 24; i++) {
			objects.TextureEyebrow[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 12; i++) {
			objects.TextureWrinkle[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 12; i++) {
			objects.TextureMakeup[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 9; i++) {
			objects.TextureGlasses[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 2; i++) {
			objects.TextureMole[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 37; i++) {
			objects.TextureMouth[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 6; i++) {
			objects.TextureMustache[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 18; i++) {
			objects.TextureNoseline[i].FromByteReader(data, objects);
		}
	}
}

public class FFLiResourceShapeHeader {
	public uint[12] ShapeMaxSize;

	public void FromByteReader!(ByteReader() data, FFLiResourceLoaderObjects() objects) {
		for (int i = 0; i < 12; i++) {
			ShapeMaxSize[i] = data.ReadUInt(4);
			assert ShapeMaxSize[i] < 20000000 && (ShapeMaxSize[i] % 2) == 0, "Shape Max Size invalid (should pass ShapeMaxSize < 20000000 and (ShapeMaxSize % 2) == 0)";
		}
		for (int i = 0; i < 4; i++) {
			objects.ShapeBeard[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 132; i++) {
			objects.ShapeCapNormal[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 132; i++) {
			objects.ShapeCapHat[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 12; i++) {
			objects.ShapeFaceline[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 1; i++) {
			objects.ShapeGlasses[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 12; i++) {
			objects.ShapeMask[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 18; i++) {
			objects.ShapeNoseline[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 18; i++) {
			objects.ShapeNose[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 132; i++) {
			objects.ShapeHairNormal[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 132; i++) {
			objects.ShapeHairHat[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 132; i++) {
			objects.ShapeForeheadNormal[i].FromByteReader(data, objects);
		}
		for (int i = 0; i < 132; i++) {
			objects.ShapeForeheadHat[i].FromByteReader(data, objects);
		}
	}
}

/// ## FFLResource
/// `FFLResource` is used for the loading of FFL / AFL Resource files.
/// ### Loading a Resource
/// Use `FFLResource.FromByteReader` to load a resource from a `ByteReader`, storing objects in a `FFLiResourceLoaderObjects` object.
public class FFLResource {
	/// Contains `true` if the resource has been loaded successfully.
	public bool IsLoaded = false;
	/// Contains `true` if the resource has been detected as `AFLResHigh_2_3.dat`.
	/// (`objects.ResourceHeader.ExpandedBufferSize == 0x2502DE0`)
	public bool IsAFL23 = false;
	/// Contains `true` if the resource has been detected as an `AFLRes*.dat` file.
	/// (`IsAFL23 || objects.ResourceHeader.ExpandedBufferSize == 0x239D5E0`)
	public bool IsAFL = false;

	/// Loads a resource from a `ByteReader`, storing objects in a `FFLiResourceLoaderObjects` object.
	public void FromByteReader!(ByteReader() data, FFLiResourceLoaderObjects() objects) {
		objects.ResourceHeader.FromByteReader(data, objects);
		IsAFL23 = objects.ResourceHeader.ExpandedBufferSize == 0x2502DE0;
		IsAFL = IsAFL23 || objects.ResourceHeader.ExpandedBufferSize == 0x239D5E0;
		objects.TextureHeader.FromByteReader(data, objects);
		objects.ShapeHeader.FromByteReader(data, objects);
		IsLoaded = true;
	}
}